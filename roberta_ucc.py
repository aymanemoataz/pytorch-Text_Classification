# -*- coding: utf-8 -*-
"""RoBERTa_ucc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dnU1638RTF4VnYUj5cocC3m6As2AIjPq
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install transformers
# !pip install pytorch-lightning

import os
import matplotlib.pyplot as plt
from google.colab import drive

drive.mount('/content/drive', force_remount = False)

import zipfile
import os
from pathlib import Path

train_path = '/content/drive/MyDrive/ucc/train.csv'
val_path = '/content/drive/MyDrive/ucc/val.csv'

"""# **Data Exploration** - Classes"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

train_data = pd.read_csv(train_path)
val_data = pd.read_csv(val_path)

train_data.head(3)

train_data.shape, train_data.isnull().sum()

train_data['unhealthy'] = np.where(train_data['healthy'] == 1, 0, 1)

atts = ['antagonize', 'condescending', 'dismissive', 'generalisation', 'generalisation_unfair', 'hostile', 'sarcastic', 'unhealthy']
train_data[atts].sum().plot.bar()

"""# **Dataset**"""

from torch.utils.data import Dataset
import torch

class UCC_Dataset(Dataset):

  def __init__(self, data_path, tokenizer, attributes, max_token_len: int = 128, sample = 5000):

    self.data_path = data_path
    self.tokenizer = tokenizer
    self.attributes = attributes
    self.max_token_len = max_token_len
    self.sample = sample
    self._prepare_data()

  def _prepare_data(self):
    data = pd.read_csv(self.data_path)
    data['unhealthy'] = np.where(data['healthy'] == 1, 0, 1)

    if self.sample is not None:
      unhealthy = data.loc[data[self.attributes].sum(axis=1) > 0]
      healthy = data.loc[data[self.attributes].sum(axis=1) == 0]
      self.data = pd.concat([unhealthy, healthy.sample(self.sample, random_state = 7)])
    
    else:
      self.data = data

  def __len__(self):
    return(len(self.data))

  def __getitem__(self, index):
    item = self.data.iloc[index]
    comment = str(item.comment)
    attributes = torch.FloatTensor(item[self.attributes])
    tokens = self.tokenizer.encode_plus(comment, add_special_tokens=True, return_tensors='pt', truncation=True, max_length= self.max_token_len,
                                        padding = 'max_length', return_attention_mask=True)
    

    return {'input_ids': tokens.input_ids.flatten(), 'attention_mask': tokens.attention_mask.flatten(), 'labels': attributes}

from transformers import AutoTokenizer
model_name = 'roberta-base'
tokenizer = AutoTokenizer.from_pretrained(model_name)

ucc_ds = UCC_Dataset(train_path, tokenizer, atts)
ucc_ds_val = UCC_Dataset(val_path, tokenizer, atts, sample = None)

ucc_ds.__getitem__(3000)

len(ucc_ds)

"""#**Data Module**"""

import pytorch_lightning as pl
from torch.utils.data import DataLoader

class UCC_Data_Module(pl.LightningDataModule):

  def __init__(self, train_path, val_path, attributes, batch_size: int = 16, max_token_len: int = 128, model_name = 'roberta-base'):

    super().__init__()
    self.train_path = train_path
    self.val_path = val_path
    self.attributes = attributes
    self.batch_size = batch_size
    self.max_token_len = max_token_len
    self.model_name = model_name
    self.tokenizer = AutoTokenizer.from_pretrained(model_name)

  def setup(self, stage = None):
    if stage in (None, "fit"):
      self.train_dataset = UCC_Dataset(self.train_path,self.tokenizer, self.attributes)
      self.val_dataset = UCC_Dataset(self.val_path, self.tokenizer, self.attributes, sample = None)

    if stage == 'predict':
      self.val_dataset = UCC_Dataset(self.val_path, self.tokenizer, self.attributes, sample = None)

  def train_dataloader(self):
    return DataLoader(self.train_dataset, batch_size = self.batch_size, num_workers = 4, shuffle =True)

  def val_dataloader(self):
    return DataLoader(self.val_dataset, batch_size = self.batch_size, num_workers = 4) # no shuffling : avoiding stochasticism in the model ...

  def predict_dataloader(self):
    return DataLoader(self.val_dataset, batch_size = self.batch_size, num_workers = 4 )

ucc_data_module = UCC_Data_Module(train_path, val_path, atts)

ucc_data_module.setup()
dl = ucc_data_module.train_dataloader()

dlv = ucc_data_module.val_dataloader()

len(dl), len(dlv)

"""#**Model**"""

from transformers import AutoModel, AdamW, get_cosine_schedule_with_warmup
import torch.nn as nn
import math
from torchmetrics.functional.classification import auroc
import torch.nn.functional as F

class UCC_Classifier(pl.LightningModule):

  def __init__(self, config: dict):
    super().__init__()
    self.config = config
    self.pretrained_model = AutoModel.from_pretrained(config['model_name'],return_dict = True)
    self.hidden = nn.Linear(self.pretrained_model.config.hidden_size, self.pretrained_model.config.hidden_size)
    self.classifier = nn.Linear(self.pretrained_model.config.hidden_size, self.config['n_labels'])
    torch.nn.init.xavier_uniform(self.hidden.weight)
    torch.nn.init.xavier_uniform(self.classifier.weight)
    self.loss_func = nn.BCEWithLogitsLoss(reduction='mean')
    self.dropout = nn.Dropout()

  def forward(self, input_ids, attention_mask, labels= None):
    # roberta model 
    output = self.pretrained_model(input_ids = input_ids, attention_mask = attention_mask)
    pooled_output = torch.mean(output.last_hidden_state, 1)
    # nn classification layers

    pooled_output = self.hidden(pooled_output)
    pooled_output = self.dropout(pooled_output)
    pooled_output = F.relu(pooled_output)
    logits = self.classifier(pooled_output)
    #calculate the loss
    loss = 0
    if labels is not None:
      loss = self.loss_func(logits.view(-1, self.config['n_labels']), labels.view(-1, self.config['n_labels']))
    
    return loss, logits

  def training_step(self, batch, batch_index):
    loss, logits = self(**batch)
    self.log("train loss", loss, prog_bar = True, logger = True)
    return {"loss" : loss, "predictions": logits, "labels" : batch['labels']}

  def validation_step(self, batch, batch_index):
    loss, logits = self(**batch)
    self.log("validation loss", loss, prog_bar = True, logger = True)
    return {"val_loss" : loss, "predictions": logits, "labels" : batch['labels']}

  def predict_step(self, batch, batch_index):
    _, logits = self(**batch)
    return logits


  def configure_optimizers(self):
    optimizer = AdamW(self.parameters(), lr = self.config['lr'], weight_decay = self.config['w_decay'])
    total_steps = self.config['train_size'] / self.config['bs']
    warmup_steps = math.floor(total_steps * self.config['warmup'])
    scheduler = get_cosine_schedule_with_warmup(optimizer, warmup_steps, total_steps)
    return [optimizer], [scheduler]

config = { 'model_name' : 'distilroberta-base',
          'n_labels' : len(atts),
          'bs' : 128,
          'lr': 1.5e-6,
          'warmup' :0.2,
          'train_size':len(ucc_data_module.train_dataloader()),
          'w_decay':0.001,
          'n_epochs': 80}

model = UCC_Classifier(config)

idx = 0
input_ids = ucc_ds.__getitem__(idx)['input_ids']
am = ucc_ds.__getitem__(idx)['attention_mask']
labels = ucc_ds.__getitem__(idx)['labels']
loss, output = model(input_ids.unsqueeze(dim=0), am.unsqueeze(dim=0), labels.unsqueeze(dim=0))

loss, output

"""#**Train**"""

# data module
ucc_data_module = UCC_Data_Module(train_path, val_path, atts, batch_size = config['bs'])
ucc_data_module.setup()


# model
model = UCC_Classifier(config)

# train
trainer = pl.Trainer(max_epochs = config['n_epochs'], gpus =1, num_sanity_val_steps = 50)
trainer.fit(model, ucc_data_module)

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir ./lightning_logs/

"""#**Predict**"""

#convert list of comments into predictions for each comment 

def classify_raw_comments(model, dm):
  predictions =  trainer.predict(model, datamodule = dm)
  predictions
  # predictions = torch.sigmoid(torch.Tensor(predictions))
  flattened_predictions = np.stack([torch.sigmoid(torch.Tensor(p)) for batch in predictions for p in batch])
  return flattened_predictions

predictions = classify_raw_comments(model, ucc_data_module)

val_data = pd.read_csv(val_path)
val_data['unhealthy'] = np.where(val_data['healthy'] == 1, 0, 1)
true_labels = np.array(val_data[atts])

from sklearn import metrics
plt.figure(figsize = (12,8))

for i,attribute in enumerate(atts):
  fpr, tpr,_ =metrics.roc_curve(true_labels[:,i].astype(int),predictions[:,i])
  auc = metrics.roc_auc_score(true_labels[:,i].astype(int), predictions[:,i])
  plt.plot(fpr, tpr, label = "%s %g" % (attribute, auc))
  plt.xlabel('False Positive Rate')
  plt.ylabel('True Positive Rate')
  plt.legend(loc='lower right')
  plt.title('RoBERTa trained on UCC dataset - AUC ROC')